{"version":3,"sources":["src/components/templateParse/updateState.js","src/components/conditionalNodes.js","src/components/templateParse/conditionalCache.js","src/components/genModelList.js","src/components/componentParse.js","src/base/svgHandler.js","src/base/clear.js","src/base/mountToFragment.js","src/components/ternaryOps.js","src/components/genModelTemplate.js","src/components/svgParse.js","src/components/templateParse/replaceCommentBlock.js","src/components/templateParse/valAssign.js","src/components/templateParse/replaceHandleBars.js","src/components/templateParse/inspectAttributes.js","src/components/templateParse/addEvent.js","src/components/templateParse/reconcile.js","src/components/templateParse/diffNodes.js","src/components/genElement.js","src/components/parseStr.js","src/base/mount.js","utils.js","src/components/strInterpreter.js","src/base/createModel.js","keet.js"],"names":["updateState","state","updateStateList","catchNode","node","start","cNode","nextSibling","nodeType","DOCUMENT_ELEMENT_TYPE","isEqualNode","remove","firstChild","resolveConditionalNodes","conditional","setup","runner","addState","currentNode","fetchFrag","frag","document","createDocumentFragment","cache","hasOwnProperty","cloneNode","call","this","parentNode","insertBefore","nodeValue","match","conditionalNodesRawEnd","__pristineFragment__","DOCUMENT_COMMENT_TYPE","appendChild","check","conditionalNodesRawStart","trim","reConditional","concat","nodes","conditionalCache","base","i","length","bind","conditionalNodes","removeProtoModel","id","p","getElementById","childNodes","genModelList","model","reconcile","modelList","listClone","list","listArg","mLength","enableFiltering","undefined","DOCUMENT_FRAGMENT_TYPE","getId","el","dirty","setAttribute","lastChild","getKeetGlobalComponent","component","window","babelHelpers.typeof","__keetGlobalComponentRef__","index","map","c","indentifier","indexOf","componentParse","componentStr","replace","cacheInit","ID","replaceChild","callBatchPoolUpdate","render","assert","parseSVG","svgList","svgRe","IS_SVG","ls","minId","svgData","clear","f","DOCUMENT_TEXT_TYPE","mountToFragment","tempDiv","createElement","innerHTML","ternaryOps","input","t","split","condition","leftHand","rightHand","value","test","genModelTemplate","string","obj","arrProps","tmpl","len","rep","isTernary","isObjectNotation","strInterpreter","result","re","svgParse","svgStr","dataStr","handle","replaceCommentBlock","fromModel","modelRep","svg","valAssign","withTo","RegExp","replaceHandleBars","isAttr","props","ln","tnr","self","ref","inspectAttributes","nodeAttributes","attributes","a","ns","name","localName","removeAttribute","lookupParentNode","rootNode","hasAttribute","getAttribute","addEvent","evtData","evtName","Object","keys","handler","addEventListener","fn","e","stopPropagation","target","currentTarget","getIndex","addEventModel","testEventNode","evtStore","obs","args","push","hasChildNodes","modelRaw","recon","_this","hasAttributes","events","isModel","instance","isEqual","oldNode","newNode","isPristine","compare","isIgnored","arbiter","nodeName","checked","setAttr","oAttr","output","iAttr","j","attr","patch","diff","store","count","newStore","checkNew","oldParentNode","checkOld","removeChild","diffNodes","IS_STUB","clearState","stateList","parseStr","stub","setState","componentDidMount","_mount","svgHandler","_typeof","genId","rd","Math","random","toString","val","msg","Error","html","_len","arguments","Array","_key","literals","shift","substs","slice","raw","reduce","acc","lit","join","str","res","m","DELAY","morpher","genElement","componentDidUpdate","timer","updateContext","delay","clearTimeout","setTimeout","nextState","isArray","inVal","defineProperty","enumerable","configurable","get","set","notEqual","b","async","inform","mId","exec","apply","CreateModel","genIdentity","listFilter","_this2","prop","filter","subscribe","add","_extends","kdata-id","update","updateObj","destroy","destroyObj","Keet","indentity","storeRef","mount","link","componentWillMount","identifier"],"mappings":"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","file":"keet-min.js","sourcesContent":["export default function (state, updateStateList) {\r\n  if (typeof updateStateList === 'function') updateStateList(state)\r\n}\r\n","const conditionalNodesRawEnd = /\\{\\{\\/([^{}]+)\\}\\}/g\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\nconst DOCUMENT_COMMENT_TYPE = 8\r\n\r\nlet cache = {}\r\n\r\n// rebuild the node structure\r\nfunction catchNode (node, start) {\r\n  let cNode\r\n  while (node) {\r\n    cNode = node\r\n    node = node.nextSibling\r\n    if (cNode && cNode.nodeType === DOCUMENT_ELEMENT_TYPE) {\r\n      if (cNode.isEqualNode(start)) {\r\n        cNode.remove()\r\n        start = start.nextSibling\r\n      } else {\r\n        catchNode(cNode.firstChild, start)\r\n      }\r\n    } else if (cNode.isEqualNode(start)) {\r\n      cNode.remove()\r\n      start = start.nextSibling\r\n    }\r\n  }\r\n}\r\n\r\nfunction resolveConditionalNodes (node, conditional, setup, runner, addState) {\r\n  let currentNode\r\n  let cNode\r\n  let fetchFrag\r\n  let frag = document.createDocumentFragment()\r\n  if (setup === 'initial' && !cache.hasOwnProperty(conditional)) {\r\n    cNode = node\r\n    while (cNode) {\r\n      currentNode = cNode\r\n      cNode = cNode.nextSibling\r\n      if (currentNode.nodeType !== DOCUMENT_ELEMENT_TYPE && currentNode.nodeValue.match(conditionalNodesRawEnd)) {\r\n        cNode = null\r\n        cache[conditional] = cache[conditional] || {}\r\n        // clean up pristine node\r\n        catchNode(this.__pristineFragment__.firstChild, frag.firstChild)\r\n        // since we work backward no need to check fragment recursive conditional states\r\n        cache[conditional].frag = frag\r\n      } else if (currentNode.nodeType !== DOCUMENT_COMMENT_TYPE) {\r\n        frag.appendChild(currentNode)\r\n      }\r\n    }\r\n  } else if (setup === 'conditional-set') {\r\n    if (node.nextSibling.isEqualNode(cache[conditional].frag.firstChild)) return\r\n    fetchFrag = cache[conditional].frag.cloneNode(true)\r\n    runner.call(this, fetchFrag.firstChild, addState)\r\n    node.parentNode.insertBefore(fetchFrag, node.nextSibling)\r\n  }\r\n}\r\n\r\nexport {\r\n  resolveConditionalNodes as default,\r\n  cache\r\n}\r\n","import updateState from './updateState'\r\nimport conditionalNodes from '../conditionalNodes'\r\n\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\nconst DOCUMENT_COMMENT_TYPE = 8\r\nconst conditionalNodesRawStart = /\\{\\{\\?([^{}]+)\\}\\}/g\r\nconst reConditional = /([^{?])(.*?)(?=\\}\\})/g\r\n\r\nlet conditional\r\nlet currentNode\r\nlet state\r\nlet nodes\r\n\r\nfunction check (node) {\r\n  while (node) {\r\n    currentNode = node\r\n    node = node.nextSibling\r\n    if (currentNode.nodeType === DOCUMENT_ELEMENT_TYPE) {\r\n      check.call(this, currentNode.firstChild)\r\n    } else if (currentNode.nodeType === DOCUMENT_COMMENT_TYPE && currentNode.nodeValue.match(conditionalNodesRawStart)) {\r\n      conditional = currentNode.nodeValue.trim().match(reConditional)\r\n      state = state.concat(conditional)\r\n      nodes = nodes.concat(currentNode)\r\n    }\r\n  }\r\n}\r\n\r\nfunction conditionalCache (addState) {\r\n  state = []\r\n  nodes = []\r\n  check.call(this, this.base.firstChild)\r\n  let i = state.length\r\n  while (i > 0) {\r\n    i--\r\n    updateState(state[i], addState.bind(this))\r\n    conditionalNodes.call(this, nodes[i], state[i], 'initial')\r\n  }\r\n}\r\n\r\nexport default conditionalCache\r\n","import { getId } from '../../utils'\r\n\r\nconst DOCUMENT_FRAGMENT_TYPE = 11\r\n// storage for model state\r\nlet cache = {}\r\n\r\nfunction removeProtoModel (node, id) {\r\n  let p = node.getElementById(id)\r\n  if (p) p.childNodes[1].remove()\r\n}\r\n\r\nfunction genModelList (node, model, reconcile) {\r\n  let modelList\r\n  let i\r\n  let listClone\r\n  let parentNode\r\n  let list\r\n  let listArg\r\n  let mLength\r\n\r\n  cache[model] = cache[model] || {}\r\n\r\n  // check if the model use filtering\r\n  listArg = this[model] && this[model].enableFiltering ? 'listFilter' : 'list'\r\n\r\n  if (!cache[model][listArg]) {\r\n    cache[model][listArg] = node.nextSibling.cloneNode(true)\r\n    node.nextSibling.remove()\r\n    // also remove from pristine nodes / conditional cache store\r\n    removeProtoModel(this.__pristineFragment__, node.parentNode.id)\r\n  }\r\n\r\n  list = cache[model][listArg]\r\n\r\n  if (this[model] !== undefined && this[model].hasOwnProperty(listArg)) {\r\n    parentNode = node.parentNode.nodeType === DOCUMENT_FRAGMENT_TYPE ? getId(this.el) : node.parentNode\r\n\r\n    modelList = this[model][listArg]\r\n\r\n    if (!this[model].dirty) {\r\n      parentNode.setAttribute('pristine-model', '')\r\n      return\r\n    }\r\n\r\n    i = 0\r\n\r\n    mLength = modelList.length\r\n\r\n    while (i < mLength) {\r\n      listClone = list.cloneNode(true)\r\n      reconcile.call(this, listClone, null, modelList[i])\r\n      listClone.setAttribute('kdata-id', modelList[i]['kdata-id'])\r\n      parentNode.insertBefore(listClone, parentNode.lastChild)\r\n      i++\r\n    }\r\n    this[model].dirty = false\r\n  }\r\n}\r\n\r\nexport default genModelList\r\n","import { assert, getId } from '../../utils'\r\n\r\nlet cacheInit = {}\r\n\r\nfunction getKeetGlobalComponent (component) {\r\n  if (window && typeof window.__keetGlobalComponentRef__ === 'object') {\r\n    let index = window.__keetGlobalComponentRef__.map(c => c.indentifier).indexOf(component)\r\n    if (~index) {\r\n      return window.__keetGlobalComponentRef__[index].component\r\n    }\r\n  }\r\n}\r\n\r\nexport default function (componentStr, node) {\r\n  const component = componentStr.replace('component:', '')\r\n  const c = this[component] || getKeetGlobalComponent(component)\r\n  if (c !== undefined) {\r\n    // this is for initial component runner\r\n    if (!cacheInit[c.ID]) {\r\n      c.render(true)\r\n      cacheInit[c.ID] = c.base.cloneNode(true)\r\n      node.parentNode.replaceChild(c.base, node)\r\n    } else {\r\n      // we need to reattach event listeners if the node is not available on DOM\r\n      if (!getId(c.el)) {\r\n        c.base = c.__pristineFragment__.cloneNode(true)\r\n        c.render(true)\r\n        node.parentNode.replaceChild(c.base, node)\r\n      } else {\r\n        node.parentNode.replaceChild(cacheInit[c.ID].cloneNode(true), node)\r\n        // inform sub-component to update\r\n        c.callBatchPoolUpdate()\r\n      }\r\n    }\r\n  } else {\r\n    assert(false, 'Component ' + component + ' does not exist.')\r\n  }\r\n}\r\n","import { minId } from '../../utils'\r\n\r\nconst svgRe = /(<svg)([^<]*|[^>]*)(.*?)(?=<\\/svg>)/g\r\n\r\nlet svgData = {}\r\n\r\nfunction parseSVG (base) {\r\n  let svgList\r\n  let id\r\n  if (typeof base === 'string') {\r\n    svgList = base.match(svgRe)\r\n    if (svgList && svgList.length) {\r\n      this.IS_SVG = true\r\n      svgList.map(ls => {\r\n        id = minId()\r\n        svgData[id] = ls\r\n        base = base.replace(ls, `<!-- {{svg:${id}}} -->`)\r\n      })\r\n    }\r\n  }\r\n  return base\r\n}\r\n\r\nexport {\r\n  parseSVG as default,\r\n  svgData\r\n}\n","const DOCUMENT_TEXT_TYPE = 3\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\n\r\n// clean up nodes\r\nfunction clear (node) {\r\n  let f\r\n  while (node) {\r\n    f = node\r\n    node = node.nextSibling\r\n    if (f.nodeType === DOCUMENT_ELEMENT_TYPE) {\r\n      clear(f.firstChild)\r\n    } else if (f.nodeType === DOCUMENT_TEXT_TYPE && f.nodeValue === ' ') {\r\n      f.remove()\r\n    }\r\n  }\r\n}\r\n\r\nexport default clear\n","import clear from './clear'\r\n\r\nexport default function (frag, base) {\r\n  let tempDiv = document.createElement('div')\r\n  tempDiv.innerHTML = base\r\n  clear(tempDiv.firstChild)\r\n  while (tempDiv.firstChild) {\r\n    frag.appendChild(tempDiv.firstChild)\r\n  }\r\n}\n","// function to resolve ternary operation\r\n\r\nconst test = str => str === '\\'\\'' || str === '\"\"' || str === 'null' ? '' : str\r\n\r\nexport default function (input) {\r\n  if (input.match(/([^?]*)\\?([^:]*):([^;]*)|(\\s*=\\s*)[^;]*/g)) {\r\n    let t = input.split('?')\r\n    let condition = t[0]\r\n    let leftHand = t[1].split(':')[0]\r\n    let rightHand = t[1].split(':')[1]\r\n\r\n    // check the condition fulfillment\r\n\r\n    if (this) {\r\n      if (this[condition]) {\r\n        return {\r\n          value: test(leftHand),\r\n          state: condition\r\n        }\r\n      } else {\r\n        return {\r\n          value: test(rightHand),\r\n          state: condition\r\n        }\r\n      }\r\n    }\r\n    return false\r\n  } else return false\r\n}\r\n","import ternaryOps from './ternaryOps'\r\nimport strInterpreter from './strInterpreter'\r\nimport updateState from './templateParse/updateState'\r\n\r\nconst re = new RegExp(/(\\schecked=\")(.*?)(?=\")/g)\r\n\r\nlet tmpl = ''\r\nlet rep\r\nlet isTernary\r\nlet i\r\nlet len\r\nlet match\r\nlet isObjectNotation\r\n\r\nexport default function (string, obj, addState) {\r\n  if (obj) {\r\n    addState = false\r\n  }\r\n  obj = obj || this\r\n  const arrProps = string.match(/{{([^{}]+)}}/g)\r\n  tmpl = string\r\n  for (i = 0, len = arrProps.length; i < len; i++) {\r\n    rep = arrProps[i].replace(/{{([^{}]+)}}/g, '$1')\r\n    isTernary = ternaryOps.call(obj, rep)\r\n    isObjectNotation = strInterpreter(rep)\r\n    if (isTernary) {\r\n      updateState(rep, addState)\r\n      tmpl = tmpl.replace('{{' + rep + '}}', isTernary.value)\r\n    } else if (isObjectNotation) {\r\n      if (isObjectNotation[0] === 'this' && typeof this[isObjectNotation[1]] === 'function') {\r\n        let result = this[isObjectNotation[1]](obj)\r\n        if (result !== undefined) {\r\n          tmpl = tmpl.replace('{{' + rep + '}}', result)\r\n        }\r\n      }\r\n    } else {\r\n      if (obj[rep] !== undefined) {\r\n        updateState(rep, addState)\r\n        tmpl = tmpl.replace('{{' + rep + '}}', obj[rep])\r\n      }\r\n    }\r\n\r\n    match = tmpl.match(re)\r\n    if (match) {\r\n      if (match[0].length === 17) { tmpl = tmpl.replace(' checked=\"checked\"', ' checked') } else { tmpl = tmpl.replace(' checked=\"\"', '') }\r\n    }\r\n  }\r\n  return tmpl\r\n}\r\n","import { svgData } from '../base/svgHandler'\r\nimport mountToFragment from '../base/mountToFragment'\r\nimport genModelTemplate from './genModelTemplate'\r\n\r\nconst handle = /{{([^{}]+)}}/g\r\n\r\nlet frag = document.createDocumentFragment()\r\n\r\nexport default function (svgStr, node, model, addState) {\r\n  let id = svgStr.replace('svg:', '')\r\n  let dataStr = svgData[id]\r\n  let base = genModelTemplate.call(this, dataStr, model, addState)\r\n  if (!base.match(handle)) {\r\n    mountToFragment(frag, base)\r\n    node.parentNode.replaceChild(frag.firstChild, node)\r\n  }\r\n}\r\n","import genModelList from '../genModelList'\r\nimport componentParse from '../componentParse'\r\nimport svgParse from '../svgParse'\r\n\r\nconst re = /{{([^{}]+)}}/g\r\nconst model = /^model:/g\r\nconst component = /^component:([^{}]+)/g\r\nconst svg = /^svg:([^{}]+)/g\r\n\r\nexport default function (value, node, reconcile, fromModel, addState) {\r\n  let rep\r\n  let modelRep\r\n\r\n  if (value.match(re)) {\r\n    rep = value.replace(re, '$1').trim()\r\n    if (rep.match(model)) {\r\n      modelRep = rep.replace('model:', '')\r\n      genModelList.call(this, node, modelRep, reconcile)\r\n    } else if (rep.match(component)) {\r\n      componentParse.call(this, rep, node)\r\n    } else if (this.IS_SVG && rep.match(svg)) {\r\n      svgParse.call(this, rep, node, fromModel, addState)\r\n    }\r\n  }\r\n}\r\n","export default function (node, replace, withTo) {\r\n  let re = new RegExp(replace, 'g')\r\n  node.nodeValue = node.nodeValue.replace(re, withTo)\r\n}\r\n","import ternaryOps from '../ternaryOps'\r\nimport strInterpreter from '../strInterpreter'\r\nimport updateState from './updateState'\r\nimport valAssign from './valAssign'\r\n\r\nconst re = /{{([^{}]+)}}/g\r\n\r\nexport default function (value, node, addState, isAttr, model) {\r\n  const props = value.match(re)\r\n  if (!props) return\r\n  let ln = props.length\r\n  let rep\r\n  let tnr\r\n  let isObjectNotation\r\n\r\n  let self = this\r\n\r\n  let ref = model || this\r\n\r\n  while (ln) {\r\n    ln--\r\n    rep = props[ln].replace(re, '$1')\r\n    tnr = ternaryOps.call(ref, rep)\r\n    isObjectNotation = strInterpreter(rep)\r\n    if (isObjectNotation) {\r\n      if (!isAttr) {\r\n        if (isObjectNotation[0] === 'this' && self[isObjectNotation[1]] !== undefined && typeof self[isObjectNotation[1]] === 'function') {\r\n          let result = self[isObjectNotation[1]]()\r\n          if (result !== undefined) {\r\n            valAssign(node, '{{' + rep + '}}', result)\r\n          }\r\n        } else {\r\n          updateState(rep, addState)\r\n          valAssign(node, '{{' + rep + '}}', self[isObjectNotation[0]][isObjectNotation[1]])\r\n        }\r\n      } else {\r\n        if (isObjectNotation[0] === 'this' && self[isObjectNotation[1]] !== undefined && typeof self[isObjectNotation[1]] === 'function') {\r\n          let result = self[isObjectNotation[1]](ref)\r\n          return result !== undefined ? result : value\r\n        } else {\r\n          updateState(rep, addState)\r\n          return value.replace(props, self[isObjectNotation[0]][isObjectNotation[1]])\r\n        }\r\n      }\r\n    } else {\r\n      if (tnr) {\r\n        updateState(tnr.state, addState)\r\n        if (!isAttr) {\r\n          // escape symbol\r\n          rep = rep.replace('?', '\\\\?')\r\n          valAssign(node, '{{' + rep + '}}', tnr.value)\r\n        } else {\r\n          return value.replace(props, tnr.value)\r\n        }\r\n      } else {\r\n        if (ref[rep] !== undefined) {\r\n          updateState(rep, addState)\r\n          if (!isAttr) {\r\n            valAssign(node, '{{' + rep + '}}', ref[rep])\r\n          } else {\r\n            return value.replace(props, ref[rep])\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import replaceHandleBars from './replaceHandleBars'\r\n\r\nconst re = /{{([^{}]+)}}/g\r\n\r\nfunction inspectAttributes (node, addState, model) {\r\n  let nodeAttributes = node.attributes\r\n  let i = 0\r\n  let a\r\n  let ns\r\n  let name\r\n\r\n  for (i = nodeAttributes.length; i--;) {\r\n    a = nodeAttributes[i]\r\n    name = a.localName\r\n    ns = a.nodeValue\r\n    if (re.test(name)) {\r\n      node.removeAttribute(name)\r\n      name = replaceHandleBars.call(this, name, node, addState, true, model)\r\n      node.setAttribute(name, ns)\r\n    } else if (re.test(ns)) {\r\n      ns = replaceHandleBars.call(this, ns, node, addState, true, model)\r\n      if (name === 'checked') {\r\n        if (ns === '') {\r\n          node.removeAttribute(name)\r\n          // node.checked = false\r\n        } else {\r\n          // node.checked = true\r\n          node.setAttribute(name, '')\r\n        }\r\n        // node.removeAttribute(name)\r\n      } else {\r\n        if (ns === '') {\r\n          node.setAttribute(name, '')\r\n        } else {\r\n          node.setAttribute(name, ns)\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default inspectAttributes\r\n","const DOCUMENT_ELEMENT_TYPE = 1\r\nconst re = /{{([^{}]+)}}/g\r\n\r\nfunction lookupParentNode (rootNode, node) {\r\n  let cNode\r\n  while (node) {\r\n    cNode = node\r\n    node = node.parentNode\r\n    if (cNode.nodeType === DOCUMENT_ELEMENT_TYPE && cNode.hasAttribute('kdata-id')) {\r\n      return { id: cNode.getAttribute('kdata-id'), node: cNode }\r\n    }\r\n    if (cNode.isEqualNode(rootNode)) {\r\n      node = null\r\n    }\r\n  }\r\n}\r\n\r\nconst getIndex = (id, model) => model.list.map(m => m['kdata-id']).indexOf(id)\r\n\r\nfunction addEvent (node, evtData) {\r\n  // delete evtData.isModel\r\n  let evtName = Object.keys(evtData)[0]\r\n  let handler = evtData[evtName]\r\n  if (this[handler] !== undefined && typeof this[handler] === 'function') {\r\n    node.addEventListener(evtName, this[handler].bind(this), !!evtData['useCapture'])\r\n  }\r\n}\r\n\r\nfunction fn (model, handler, node, e) {\r\n  e.stopPropagation()\r\n  if (e.target !== e.currentTarget) {\r\n    let t = lookupParentNode(node, e.target)\r\n    this[handler](model.list[getIndex(t.id, model)], e.target, t.node, e)\r\n  }\r\n}\r\n\r\nfunction addEventModel (node, evtData) {\r\n  // delete evtData.isModel\r\n  let evtName = Object.keys(evtData)[0]\r\n  let handler = evtData[evtName]\r\n  if (this[handler] !== undefined && typeof this[handler] === 'function') {\r\n    let rep = node.firstChild.nodeValue.replace(re, '$1').trim()\r\n    rep = rep.replace('model:', '')\r\n    let model = this[rep]\r\n    node.addEventListener(evtName, fn.bind(this, model, handler, node), !!evtData['useCapture'])\r\n  }\r\n}\r\n\r\nexport {\r\n  addEvent,\r\n  addEventModel\r\n}\r\n","import replaceCommentBlock from './replaceCommentBlock'\r\nimport inspectAttributes from './inspectAttributes'\r\nimport replaceHandleBars from './replaceHandleBars'\r\nimport conditionalNodes from '../conditionalNodes'\r\n\r\nimport { getId } from '../../../utils'\r\nimport { addEvent, addEventModel } from './addEvent'\r\n\r\nconst conditionalNodesRawStart = /\\{\\{\\?([^{}]+)\\}\\}/g\r\nconst reConditional = /([^{?])(.*?)(?=\\}\\})/g\r\nconst re = /{{([^{}]+)}}/g\r\nconst modelRaw = /\\{\\{model:([^{}]+)\\}\\}/g\r\n\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\nconst DOCUMENT_COMMENT_TYPE = 8\r\n\r\nfunction testEventNode (node) {\r\n  let nodeAttributes = node.attributes\r\n  let i = 0\r\n  let a\r\n  let name\r\n  let value\r\n  let evtName\r\n  let handler\r\n  let evtStore = []\r\n  let obs\r\n  let args\r\n\r\n  while (i < nodeAttributes.length) {\r\n    a = nodeAttributes[i]\r\n    name = a.localName\r\n    value = a.nodeValue\r\n    if (/^k-/.test(name)) {\r\n      evtName = name.replace(/^k-/, '')\r\n      handler = value.match(/[a-zA-Z]+(?![^(]*\\))/)[0]\r\n      args = value.match(/\\(([^{}]+)\\)/)\r\n      args = args ? args[1] : ''\r\n      obs = {}\r\n      obs[evtName] = handler\r\n      if (args) obs[args] = true\r\n      obs['isModel'] = false\r\n      evtStore.push(obs)\r\n      if (node.hasChildNodes() && node.firstChild.nodeType !== DOCUMENT_ELEMENT_TYPE && node.firstChild.nodeValue.match(modelRaw)) {\r\n        obs['isModel'] = true\r\n      }\r\n    }\r\n    i++\r\n  }\r\n  return evtStore\r\n}\r\n\r\nlet events\r\nlet c\r\nlet currentNode\r\n\r\nfunction recon (node, addState, model) {\r\n  while (node) {\r\n    currentNode = node\r\n    node = node.nextSibling\r\n    if (currentNode.nodeType === DOCUMENT_ELEMENT_TYPE) {\r\n      if (currentNode.hasAttributes()) {\r\n        inspectAttributes.call(this, currentNode, addState, model)\r\n\r\n        // to take advantage of caching always assigned id to the node\r\n        // we only assign eventListener on first mount to DOM or when the node is not available on DOM\r\n        if (!getId(currentNode.id)) {\r\n          events = testEventNode.call(this, currentNode)\r\n          if (events.length) {\r\n            events.map(e => {\r\n              !e.isModel ? addEvent.call(this, currentNode, e) : addEventModel.call(this, currentNode, e)\r\n              currentNode.removeAttribute(`k-${Object.keys(e)[0]}`)\r\n            })\r\n          }\r\n        }\r\n      }\r\n      recon.call(this, currentNode.firstChild, addState, model)\r\n    } else if (currentNode.nodeType === DOCUMENT_COMMENT_TYPE && currentNode.nodeValue.match(conditionalNodesRawStart)) {\r\n      c = currentNode.nodeValue.trim().match(reConditional)\r\n      c = c && c[0]\r\n      if (this[c]) {\r\n        conditionalNodes.call(this, currentNode, c, 'conditional-set', reconcile, addState)\r\n      }\r\n    } else if (currentNode.nodeType === DOCUMENT_COMMENT_TYPE && currentNode.nodeValue.match(re) && !currentNode.nodeValue.match(conditionalNodesRawStart)) {\r\n      replaceCommentBlock.call(this, currentNode.nodeValue, currentNode, reconcile, model, addState)\r\n    } else {\r\n      replaceHandleBars.call(this, currentNode.nodeValue, currentNode, addState, null, model)\r\n    }\r\n  }\r\n}\r\n\r\nfunction reconcile (instance, addState, model) {\r\n  recon.call(this, instance, addState, model)\r\n}\r\n\r\nexport default reconcile\r\n","import { getId } from '../../../utils'\r\n\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\n\r\nfunction isEqual (oldNode, newNode) {\r\n  return (\r\n    isPristine(newNode) ||\r\n    compare(oldNode, newNode) ||\r\n    oldNode.isEqualNode(newNode)\r\n  )\r\n}\r\n\r\nfunction compare (oldNode, newNode) {\r\n  return isIgnored(oldNode) && isIgnored(newNode)\r\n}\r\n\r\nfunction isIgnored (node) {\r\n  return node.getAttribute('data-ignore') != null\r\n}\r\n\r\nfunction arbiter (oldNode, newNode) {\r\n  if (oldNode.nodeName !== 'INPUT') return\r\n  if (oldNode.checked !== newNode.checked) {\r\n    oldNode.checked = newNode.checked\r\n  }\r\n}\r\n\r\nfunction setAttr (oldNode, newNode) {\r\n  let oAttr = newNode.attributes\r\n  let output = {}\r\n  let i = 0\r\n  while (i < oAttr.length) {\r\n    output[oAttr[i].name] = oAttr[i].value\r\n    i++\r\n  }\r\n  let iAttr = oldNode.attributes\r\n  let input = {}\r\n  let j = 0\r\n  while (j < iAttr.length) {\r\n    input[iAttr[j].name] = iAttr[j].value\r\n    j++\r\n  }\r\n  for (let attr in output) {\r\n    if (oldNode.attributes[attr] && oldNode.attributes[attr].name === attr && oldNode.attributes[attr].value !== output[attr]) {\r\n      oldNode.setAttribute(attr, output[attr])\r\n    } else {\r\n      // add new attributes as long is not part of k-<eventListener>\r\n      if (!oldNode.hasAttribute(attr) && !/^k-/.test(attr)) {\r\n        oldNode.setAttribute(attr, output[attr])\r\n      }\r\n    }\r\n  }\r\n  for (let attr in input) {\r\n    // if attributes does not exist on the new node we removed it from the old node\r\n    if (newNode.attributes[attr] && oldNode.attributes[attr]) {\r\n    } else {\r\n      oldNode.removeAttribute(attr)\r\n    }\r\n  }\r\n}\r\n\r\nfunction patch (oldNode, newNode) {\r\n  if (oldNode.nodeType === newNode.nodeType) {\r\n    if (oldNode.nodeType === DOCUMENT_ELEMENT_TYPE) {\r\n      arbiter(oldNode, newNode)\r\n      if (isEqual(oldNode, newNode)) return\r\n      diff(oldNode.firstChild, newNode.firstChild)\r\n      if (oldNode.nodeName === newNode.nodeName) {\r\n        setAttr(oldNode, newNode)\r\n      } else {\r\n        oldNode.parentNode.replaceChild(newNode, oldNode)\r\n      }\r\n    } else {\r\n      if (oldNode.nodeValue !== newNode.nodeValue) {\r\n        oldNode.nodeValue = newNode.nodeValue\r\n      }\r\n    }\r\n  } else {\r\n    oldNode.parentNode.replaceChild(newNode, oldNode)\r\n  }\r\n}\r\n\r\nfunction getIndex (store, count) {\r\n  return store.length - count - 1\r\n}\r\n\r\nlet checkNew\r\nlet checkOld\r\n\r\nfunction diff (oldNode, newNode) {\r\n  let count = 0\r\n  let newStore = []\r\n  while (newNode) {\r\n    count++\r\n    checkNew = newNode\r\n    newNode = newNode.nextSibling\r\n    newStore.push(checkNew)\r\n  }\r\n  let index\r\n  let oldParentNode = oldNode && oldNode.parentNode\r\n  while (oldNode) {\r\n    count--\r\n    checkOld = oldNode\r\n    oldNode = oldNode.nextSibling\r\n    index = getIndex(newStore, count)\r\n    if (checkOld && newStore[index]) {\r\n      patch(checkOld, newStore[index])\r\n    } else if (checkOld && !newStore[index]) {\r\n      oldParentNode.removeChild(checkOld)\r\n    }\r\n    if (oldNode === null) {\r\n      while (count > 0) {\r\n        count--\r\n        index = getIndex(newStore, count)\r\n        oldParentNode.appendChild(newStore[index])\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction isPristine (node) {\r\n  return node.hasAttribute('pristine-model')\r\n}\r\n\r\nfunction diffNodes (instance) {\r\n  let base = getId(this.el)\r\n  if (base && !this.IS_STUB) {\r\n    diff(base.firstChild, instance)\r\n  } else if (base && !isPristine(instance)) {\r\n    diff(base.firstChild, instance.firstChild)\r\n  }\r\n}\r\n\r\nexport default diffNodes\r\n","\r\nimport reconcile from './templateParse/reconcile'\r\nimport diffNodes from './templateParse/diffNodes'\r\nimport strInterpreter from './strInterpreter'\r\n\r\nconst DELAY = 0\r\n\r\nconst morpher = function () {\r\n  genElement.call(this)\r\n  // exec life-cycle componentDidUpdate\r\n  if (this.componentDidUpdate && typeof this.componentDidUpdate === 'function') {\r\n    this.componentDidUpdate()\r\n  }\r\n}\r\n\r\nlet timer = {}\r\n\r\nconst updateContext = function (fn, delay) {\r\n  timer[this.ID] = timer[this.ID] || null\r\n  clearTimeout(timer[this.ID])\r\n  timer[this.ID] = setTimeout(() => fn.call(this), delay)\r\n}\r\n\r\nconst nextState = function (i) {\r\n  let self = this\r\n  let state\r\n  let value\r\n  if (!stateList[this.ID]) return\r\n  if (i < stateList[this.ID].length) {\r\n    state = stateList[this.ID][i]\r\n    value = this[state]\r\n\r\n    // if value is undefined, likely has object notation we convert it to array\r\n    if (value === undefined) value = strInterpreter(state)\r\n\r\n    if (value && Array.isArray(value)) {\r\n      // using split object notation as base for state update\r\n      let inVal = this[value[0]][value[1]]\r\n\r\n      Object.defineProperty(this[value[0]], value[1], {\r\n        enumerable: false,\r\n        configurable: true,\r\n        get: function () {\r\n          return inVal\r\n        },\r\n        set: function (val) {\r\n          inVal = val\r\n          updateContext.call(self, morpher, DELAY)\r\n        }\r\n      })\r\n    } else {\r\n      // handle parent state update if the state is not an object\r\n      Object.defineProperty(this, state, {\r\n        enumerable: false,\r\n        configurable: true,\r\n        get: function () {\r\n          return value\r\n        },\r\n        set: function (val) {\r\n          value = val\r\n          updateContext.call(self, morpher, DELAY)\r\n        }\r\n      })\r\n    }\r\n    i++\r\n    nextState.call(this, i)\r\n  }\r\n}\r\n\r\nconst setState = function () {\r\n  nextState.call(this, 0)\r\n}\r\n\r\nlet stateList = {}\r\n\r\nfunction clearState () {\r\n  if (stateList[this.ID]) stateList[this.ID] = []\r\n}\r\n\r\nfunction addState (state) {\r\n  stateList[this.ID] = stateList[this.ID] || []\r\n  if (stateList[this.ID].indexOf(state) === -1) { stateList[this.ID] = stateList[this.ID].concat(state) }\r\n}\r\n\r\nconst genElement = function () {\r\n  this.base = this.__pristineFragment__.cloneNode(true)\r\n  reconcile.call(this, this.base.firstChild, addState.bind(this))\r\n  diffNodes.call(this, this.base.firstChild)\r\n}\r\n\r\nexport {\r\n  genElement,\r\n  addState,\r\n  setState,\r\n  clearState,\r\n  updateContext,\r\n  morpher\r\n}\r\n","import conditionalCache from './templateParse/conditionalCache'\r\nimport reconcile from './templateParse/reconcile'\r\nimport { setState, addState } from './genElement'\r\nimport { getId, assert } from '../../utils'\r\n\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\n\r\nexport default function (stub) {\r\n  conditionalCache.call(this, addState.bind(this))\r\n  reconcile.call(this, this.base.firstChild, addState.bind(this))\r\n  const el = stub || getId(this.el)\r\n  if (el) {\r\n    if (el.nodeType === DOCUMENT_ELEMENT_TYPE) {\r\n      el.setAttribute('data-ignore', '')\r\n    } else {\r\n      assert(this.base.childNodes.length === 1, 'Sub-component should only has a single rootNode.')\r\n      !this.base.firstChild.hasAttribute('data-ignore') && this.base.firstChild.setAttribute('data-ignore', '')\r\n    }\r\n    // listen to state changes\r\n    setState.call(this)\r\n    // mount fragment to DOM\r\n    if (!stub) {\r\n      el.appendChild(this.base)\r\n    }\r\n\r\n    // since component already rendered, trigger its life-cycle method\r\n    if (this.componentDidMount && typeof this.componentDidMount === 'function') {\r\n      this.componentDidMount()\r\n    }\r\n  } else {\r\n    assert(false, 'No element with id: \"' + this.el + '\" exist.')\r\n  }\r\n}\r\n","import { clearState } from '../components/genElement'\r\nimport svgHandler from './svgHandler'\r\nimport { assert } from '../../utils'\r\nimport mountToFragment from './mountToFragment'\r\n\r\nconst DOCUMENT_FRAGMENT_TYPE = 11\r\nconst DOCUMENT_TEXT_TYPE = 3\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\n\r\n/**\r\n * @private\r\n * @description\r\n * Mount an instance of string or html elements\r\n *\r\n * @param {String|Object} instance - the html/string\r\n */\r\nexport default function (instance) {\r\n  let base\r\n  let frag = document.createDocumentFragment()\r\n\r\n  // cleanup states on mount\r\n  clearState.call(this)\r\n\r\n  // Before we begin to parse an instance, do a run-down checks\r\n  // to clean up back-tick string which usually has line spacing.\r\n  if (typeof instance === 'string') {\r\n    // cleanup spacing\r\n    base = instance.trim().replace(/\\s+/g, ' ')\r\n\r\n    // parse svg elements\r\n    base = svgHandler.call(this, base)\r\n\r\n    mountToFragment(frag, base)\r\n\r\n  // If instance is a html element process as html entities\r\n  } else if (typeof instance === 'object' && instance['nodeType']) {\r\n    // parse svg elements\r\n\r\n    if (instance['nodeType'] === DOCUMENT_ELEMENT_TYPE) {\r\n      frag.appendChild(instance)\r\n    } else if (instance['nodeType'] === DOCUMENT_FRAGMENT_TYPE) {\r\n      frag = instance\r\n    } else if (instance['nodeType'] === DOCUMENT_TEXT_TYPE) {\r\n      frag.appendChild(instance)\r\n    } else {\r\n      assert(false, 'Unable to parse instance, unknown type.')\r\n    }\r\n  } else {\r\n    assert(false, 'Parameter is not a string or a html element.')\r\n  }\r\n  // we store the pristine instance in __pristineFragment__\r\n  this.__pristineFragment__ = frag.cloneNode(true)\r\n  this.base = frag\r\n\r\n  return this\r\n}\r\n","const genId = () => {\r\n  const rd = () => (Math.random() * 1 * 1e17).toString(36)\r\n  return `KDATA-${rd()}-${rd()}`\r\n}\r\n\r\nconst minId = () => (Math.random() * 1 * 1e17).toString(36)\r\n\r\nconst getId = id => document.getElementById(id)\r\n\r\n/**\r\n * @private\r\n * @description\r\n * Check a node availability in 100ms, if not found silenty skip the event\r\n * or execute a callback\r\n *\r\n * @param {string} id - the node id\r\n * @param {function} callback - the function to execute on success\r\n * @param {function} notFound - the function to execute on failed\r\n */\r\nconst checkNodeAvailability = (component, componentName, callback, notFound) => {\r\n  let ele = getId(component.el)\r\n  let found = false\r\n  let t\r\n  function find () {\r\n    ele = getId(component.el)\r\n    if (ele) {\r\n      clearInterval(t)\r\n      found = true\r\n      callback(component, componentName, ele)\r\n    }\r\n  }\r\n  function fail () {\r\n    clearInterval(t)\r\n    if (!found && notFound && typeof notFound === 'function') notFound()\r\n  }\r\n  if (ele) return ele\r\n  else {\r\n    t = setInterval(find, 0)\r\n    // ignore finding the node after sometimes\r\n    setTimeout(fail, 5)\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * @description\r\n * Confirm that a value is truthy, throws an error message otherwise.\r\n *\r\n * @param {*} val - the val to test.\r\n * @param {string} msg - the error message on failure.\r\n * @throws {Error}\r\n */\r\nconst assert = (val, msg) => {\r\n  if (!val) throw new Error('(keet) ' + msg)\r\n}\r\n\r\n/**\r\n * @private\r\n * @description\r\n * Simple html template literals MODIFIED from : http://2ality.com/2015/01/template-strings-html.html\r\n * by Dr. Axel Rauschmayer\r\n * no checking for wrapping in root element\r\n * no strict checking\r\n * remove spacing / indentation\r\n * keep all spacing within html tags\r\n * include handling ${} in the literals\r\n */\r\nconst html = (...args) => {\r\n  const literals = args.shift()\r\n  const substs = args.slice()\r\n\r\n  let result = literals.raw.reduce((acc, lit, i) => acc + substs[i - 1] + lit)\r\n  // remove spacing, indentation from every line\r\n  result = result.split(/\\n+/)\r\n  result = result.map(t => t.trim()).join('')\r\n  return result\r\n}\r\n\r\nexport {\r\n  html,\r\n  assert,\r\n  checkNodeAvailability,\r\n  genId,\r\n  getId,\r\n  minId\r\n}\r\n","export default (str) => {\r\n  let res = str.match(/\\.*\\./g)\r\n  let result\r\n  if (res && res.length > 0) {\r\n    return str.split('.')\r\n  }\r\n  return result\r\n}\r\n","import { minId } from '../../utils'\r\n\r\n/**\r\n * @module keet/CreateModel\r\n * @example\r\n * import { CreateModel } from 'keet'\r\n *\r\n * class myModel extends CreateModel {\r\n *   contructor() {\r\n *     super()\r\n *     // props\r\n *   }\r\n *   // new extended method\r\n *   myMethod(...args){\r\n *     this.list = args\r\n *   }\r\n * }\r\n *\r\n * const MyModel = new myModel()\r\n */\r\n\r\n// check two objects properties attribute kdata-id and return the value equality\r\nconst notEqual = function (a, b) {\r\n  return a['kdata-id'] !== b['kdata-id']\r\n}\r\n\r\nlet async = {}\r\n\r\n// We otimize component lifeCycle triggering by trottling the model batch updates\r\nconst inform = function (...args) {\r\n  if (async[this.mId]) clearTimeout(async[this.mId])\r\n  async[this.mId] = setTimeout(() =>\r\n    this.exec && typeof this.exec === 'function' && this.exec.apply(null, args)\r\n    , 0)\r\n}\r\n\r\n/**\r\n * The model constructor, use with template literal having\r\n * ```{{model:<myModel>}}<myModelTemplateString>{{/model:<myModel>}}```\r\n * @alias module:keet/createModel\r\n * @param {*} enableFiltering - any truthy value\r\n *\r\n */\r\nexport default class CreateModel {\r\n  constructor (enableFiltering) {\r\n    this.mId = CreateModel.genIdentity\r\n\r\n    async[this.mId] = null\r\n    // if enableFiltering is assigned a value, model generation will\r\n    // use `listFilter` instead of `list`\r\n    this.enableFiltering = enableFiltering || null\r\n\r\n    this.model = []\r\n\r\n    // Register callback listener of any changes\r\n    Object.defineProperty(this, 'list', {\r\n      enumerable: false,\r\n      configurable: true,\r\n      get: function () {\r\n        return this.model\r\n      },\r\n      set: function (val) {\r\n        this.model = val\r\n        this.dirty = true\r\n        inform.call(this, this.model, this.listFilter)\r\n      }\r\n    })\r\n\r\n    // Register callback listener of any changes with filter\r\n    Object.defineProperty(this, 'listFilter', {\r\n      enumerable: false,\r\n      configurable: true,\r\n      get: function () {\r\n        return !this.prop ? this.model : this.model.filter(obj => obj[this.prop] === this.value)\r\n      }\r\n    })\r\n  }\r\n\r\n  // set identity for this model\r\n  static get genIdentity () {\r\n    return minId()\r\n  }\r\n\r\n  /**\r\n   * Subscribe to the model changes, the function callback first argument\r\n   * is the ```model.list``` and the second argument is ```model.listFilter```\r\n   * @param {Function} fn - the function callback for the subscribe\r\n   */\r\n  subscribe (fn) {\r\n    this.exec = fn\r\n  }\r\n\r\n  /**\r\n   * Add new object to the model list\r\n   * @param {Object} obj - new object to add into the model list\r\n   */\r\n  add (obj) {\r\n    this.list = this.list.concat({ ...obj, 'kdata-id': minId() })\r\n  }\r\n\r\n  /**\r\n   * Update existing object in the model list\r\n   * @param {Object} updateObj - the updated properties\r\n   */\r\n  update (updateObj) {\r\n    this.list = this.list.map(obj =>\r\n      notEqual(obj, updateObj) ? obj : updateObj\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Filter the model data by selected properties, constructor\r\n   * instantiation should be apply with boolean true as argument\r\n   * to enable filtering\r\n   * @param {string} prop - property of the object\r\n   * @param {Object|string|number|Boolean} value - property value\r\n   */\r\n  filter (prop, value) {\r\n    this.prop = prop\r\n    this.value = value\r\n    this.list = this.list\r\n  }\r\n\r\n  /**\r\n * Removed existing object in the model list\r\n * @param {Object} destroyObj - the object ref to remove from the model\r\n */\r\n  destroy (destroyObj) {\r\n    this.list = this.list.filter(obj => {\r\n      return notEqual(obj, destroyObj)\r\n    })\r\n  }\r\n}\r\n","\r\n//\r\n// Keetjs v4.1.0 Alpha release: https://github.com/keetjs/keet\r\n// Minimalist view layer for the web\r\n//\r\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Keetjs >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n//\r\n// Copyright 2018, Shahrul Nizam Selamat\r\n// Released under the MIT License.\r\n//\r\n\r\n/**\r\n * @module keet\r\n * @example\r\n * import Keet from 'keet'\r\n *\r\n * class App extends Keet {\r\n *   contructor() {\r\n *     super()\r\n *     // props\r\n *   }\r\n *   // new extended method\r\n *   myMethod(...args){\r\n *     //\r\n *   }\r\n * }\r\n *\r\n * const app = new App()\r\n */\r\n\r\nimport parseStr from './src/components/parseStr'\r\nimport { updateContext, morpher } from './src/components/genElement'\r\nimport { genId, assert, html } from './utils'\r\nimport CreateModel from './src/base/createModel'\r\nimport mount from './src/base/mount'\r\n\r\n/**\r\n *\r\n * The main constructor of Keet\r\n * @param {string} name - ***optional*** A name to store in global ref\r\n */\r\nclass Keet {\r\n  constructor (name) {\r\n    this.ID = Keet.indentity\r\n    if (name) {\r\n      this.storeRef(name)\r\n    }\r\n  }\r\n\r\n  // generate ID for the component\r\n  static get indentity () {\r\n    return genId()\r\n  }\r\n\r\n  /**\r\n   * Mount an instance of html/string template\r\n   * @param {Object|string} instance - the html/string template\r\n   */\r\n  mount (instance) {\r\n    return mount.call(this, instance)\r\n  }\r\n\r\n  /**\r\n   * Link to DOM node attribute ```id```\r\n   * @param {string} id - the id of the node\r\n   */\r\n  link (id) {\r\n    if (!id) assert(id, 'No id is given as parameter.')\r\n    this.el = id\r\n    this.render()\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * Render this component to the DOM\r\n   * @param {Boolean} stub - set as true if this a child component\r\n   */\r\n  render (stub) {\r\n    // life-cycle method before rendering the component\r\n    if (this.componentWillMount && typeof this.componentWillMount === 'function') {\r\n      this.componentWillMount()\r\n    }\r\n\r\n    // Render this component to the target DOM\r\n    if (stub) {\r\n      this.IS_STUB = true\r\n    }\r\n    parseStr.call(this, stub)\r\n  }\r\n\r\n  /**\r\n   * Recheck all states if anything changed, diffing will occurs.\r\n   * this method is ***asynchronous*** and ***trottled***, you can call it from a loop and\r\n   * only trigger diffing when the loop end\r\n   */\r\n  callBatchPoolUpdate () {\r\n    updateContext.call(this, morpher, 1)\r\n  }\r\n  /**\r\n   * Another component can subscribe to changes on this component.\r\n   * This is the subscribe method\r\n   * @param {Function} fn - the callback function for the subscribe\r\n   */\r\n  subscribe (fn) {\r\n    this.exec = fn\r\n  }\r\n  /**\r\n   * Another component can subscribe to changes on this component.\r\n   * This is the publish method\r\n   * @param {...*} value - one or more parameters to publish to subscribers\r\n   */\r\n  inform (...args) {\r\n    this.exec && typeof this.exec === 'function' && this.exec.apply(null, args)\r\n  }\r\n\r\n  /**\r\n   * Store referance in the global space, with this the parent component do need\r\n   * to store/assign it as a property while still be able to look for the sub-component\r\n   * to initialize it\r\n   * @param {string} name - Identifier for the component, should be unique to avoid conflict\r\n   */\r\n  storeRef (name) {\r\n    window.__keetGlobalComponentRef__ = window.__keetGlobalComponentRef__ || []\r\n    let isExist = window.__keetGlobalComponentRef__.map(c => c.identifier).indexOf(name)\r\n    if (~isExist) {\r\n      assert(false, `The component name: ${name} already exist in the global pool.`)\r\n    } else {\r\n      window.__keetGlobalComponentRef__ = window.__keetGlobalComponentRef__.concat({\r\n        identifier: name,\r\n        component: this\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nexport {\r\n  Keet as default,\r\n  html,\r\n  CreateModel\r\n}\r\n"]}